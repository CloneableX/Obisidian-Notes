### 流

对现实世界事物建模时，由于事物中存在随时间变化的状态，目前只能通过赋值和可变对象实现。虽然可以解决建模的问题，但由于赋值的引入带来了许多棘手的问题，于是我们亟需一种既能完成建模需求，又不使用赋值操作（避免赋值操作带来的问题）的方法。

这种新的解决方案为数据结构——**流 （streams）**。从数据抽象的角度出发，流与[列表](obsidian://open?vault=SICP&file=data%2FSequence)是一致的，但列表在数据规模增大时会极大消耗计算资源。因为在列表的流式操作中（`filter`、`map`、`accumulate` 等操作）需要不断拷贝和生成新的全量列表，在最终只需要其中少量数据参与计算的情况下，这种代价是巨大的。所以流与列表的不同之处在于它能够延迟计算（或者说按需计算），当元素尚未被需要时流不会主动对其进行计算。

流的具体实现可以查看[流的相关操作](obsidian://open?vault=SICP&file=procedures%2Fspecial-forms%2Fstream%20expression)

#### 弊端

虽然流在建模上避免了赋值操作带来的问题，完全继承了函数式编程的优势，但它不够直观，使程式的实现和理解变得复杂。而且即使流没有通过赋值和局部状态变量为程序带来现实世界的时间问题，但时间问题依然存在，不过它被转移到了整个系统上而已，特别是在独立实体之间的建模上时间问题将彻底浮现。它与可变对象在建模上都有自身的优势，但也都不完美，完美的方法依然尚未出现。

#### 无限流

基本的流，它看起来拥有完整的元素，但实际上只计算当前访问时需要的元素。在这种情况下，即使序列很长也可以通过流进行高效的计算。更引人注目的是还可以通过流表示无限长的序列。按如下方式可以实现一个整数的无限流。

```scheme
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))
```

具体使用如下。

```scheme
(stream-ref integers 100)
100
```

其中的 `stream-ref` 功能与 `list-ref` 类似，能够读取流中的第 n 个元素。

#### 隐式流

除了上述的方式实现无限流外，还可以通过自引用的方式形成循环回调，实现无限流。下列程式将实现一个斐波那契数列的无限流。

```scheme
(define fibs
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
```

其中 `add-streams` 能够计算两个流逐个元素的和，并形成一个新流。

