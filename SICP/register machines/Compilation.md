在高级编程语言与寄存器机器语言的转换中主要有两种方案，一种是[解释器](obsidian://open?vault=SICP&file=register%20machines%2FExplicit-Control%20Evaluator)，另一种是编译。

解释器对高级编程语言进行边解析边运行的方式，这有利于代码编写时的交互，也有利于代码问题排查。但由于要防止寄存器在每一步计算中被占用，导致计算错误，所以要不断使用堆栈对寄存器内容进行存储，虽然有些情况是必要的，但有些情况却会造成浪费。

编译方案会将高级编程语言完全转换为寄存器机器指令序列，最后再由寄存器机器执行。所以编译策略会缺少解释器策略的交互性，对于错误排查也没有那么便利，但是它能够极大地提高转化后指令序列的执行效率，因为在编译过程中可以在很多优化点上做文章。比如有些堆栈操作是没有必要的，编译操作可以根据不同的指令上下文决定堆栈的操作，避免堆栈的浪费。还例如，编译过程中可以为变量绑定的框架和位置进行记录，当在环境中进行变量查找时就可以直接根据偏移量找到，不再需要递归遍历所有的变量，这种方式称为 **词法地址（lexical address）**，而实施该方案需要维护 **编译时环境（compile-time environment）** 结构。

由于两种方案的优势互补，所以现代的许多开发环境都是两者兼具，这样便可以在保持代码交互和问题排查上的便利，也能够拥有代码执行时的高效。